/*
	Template Instantiation

	The process of generating a class
	or a function from  a template plus
	a template arugment list is called 
	template instantiation.

	Templates are flexible in composing
	code:
	
	To produce impressive code quality,
	a compiler combines code(information)
	from 
	1. The template definition and its
	   lexical environment.
	2. the template arguments and their
	   lexical environment
	3. the environment of the template's 
	   use.

	The problem with this is that code in
	a template definition isn't as localized
	as we would prefer.

	The generated classes and functions are
	called specializations.

	Specializations generated by compiler -
	generated specializations.

	explicit specializations - written by
	the programmer.

	By default, the compiler generates classes
	and functions from the templates used
	in accordance with the name-binding rules.

	It is important for the programmer to be
	able to state specifically where code
	should be generated from a template.
	By doing so the programmer gains detailed
	control over the context of the instantiation.

	When is intantiation needed?

	It is necessary to generate a specialization
	of a class template only if the class's definition
	is needed.

	In particular, to declare a pointer to some
	class, the actual definition of a class is 
	not needed
*/

class Z;
Z* p; // Ok: no definition of X needed
Z a; // error: definition of Z is needed

/*
   A template class is not instantiated
   unless its definition is actually needed.
*/

template<typename T>
class Node {
	Node* next; // Ok: no definition of Node needed
	// ..
};

Node<int>* node; // no instantiation of NOde needed
Node<int> nd; // now we need to instantiate Node<int>

/* 
	A place where a template is used defines its
	instantiation point.
	
	An implementation instantiates a template
	function only if that function has been used.

	By used we mean called or had its address taken.
	
	Instantiation of a class template does not
	imly the instantiation of all its member functions.
	This allows the programmer an important degree
	of flexiblity when defining a template class.

*/

template<typename T>
class List {
	// ..
	void sort();
};

class Glob {
	// ..
};

void f(List<Glob>& lb, List<string>& ls)
{
	ls.sort();
	// .. use operations on lb, but not lb.sort()
}

/* 
	Manual Control of Instantiation

	need arises from
	1. optimize the compile-and-link process
	   by eliminating redundant replicated
	   instantiations
	2. know exactly which point is used
	   for instantiation to eliminate surprises.

	An explicit instantiation request (explicit instantiation
	) is a declaration of a specialization prefixed
	by the keyword template (not followed by .)
*/

template class vector<int>; // class
template int& vector<int>::operator[](int); // member function
template int convert<int, double>(double);

/*
  
  When a class template is explicitly instantiated,
  every member function is also instantiated.

  Bundling most template instantiations into one
  single compilation unit reduces compilation time.

  To complement explicit instantiation requests,
  the language provides explicit requests not to
  instantiate (usually extern templates).

  The obvious use is to have one explicit 
  instantiation for a specialization and use
  extern templates for its use in other 
  translation units.

*/

#include "Myvector.h"

extern template class MyVector<int>;

void foo(MyVector<int>& v)
{
	// .. use the vector here ..
}

/*
  In addition to generating specializations
  for all members of a class, the explicit
  instantiation also determines a single point
  of instantiation so that other points of
  instantiation can be ignored.
  One use of this is to place the explicit
  instantiation in a shared library. 

 */


/*
	Name Binding

	Define template functiont to minimize
	dependencies on nonlocal information.

	The reason is that a template will be
	used to generate functions and classes
	based on unknown types and in unknown
	contexts.

	Every subtle context dependency is likely
	to surface as a problem.

	Avoid global names as much as possible.
	
	Thus, we try to make template definitions
	as self-contained as possible and to
	supply much of what would otherwise have
	been global context in the form of
	template arguments (e.g traits).

	Use concepts to document dependencies 
	on template arguments.
	
	When something needs to be nonlocal,
	prefer a named namepsace to the global
	scope. Doing so preserves some locality.

	The process of finding the declaration
	for each name explicitly or implicitly 
	used in a template is called name binding.

	When defining a function template, we want
	to assure that enough context is available
	for the template definition to make sense
	in terms of its actual arguments without
	picking up "accidental stuff" from the 
	environment of a point of use.

	Categories of names used in template definitions
	1. Dependent names: names that depend on a template
	   parameter. Such names are bound at point of
	   instantiation.
	2. Nondependent names: names that don't dpend on
	   a template parameter. Such names are bound at
	   the point of definition of the template.

	To be considered, both dependent and independent
	names must either be in scope at the point of
	use or be found by argument-dependent lookup 
	(ADL).
	
	Dependent Names
	------------------------------------
	A function call is said to depend on a template
	argument if and only if one of these conditions
	holds true.

	1. The type of actual argument depends on a template
	   parameter T according to the type deduction
	   rules for example f(T(1), f(t), f(g(T)) and f(&t),
	   assuming that t is a T.
	2. The function called has a parameter that depends
	   on T according to the type deduction rules
	   f(T), f(list<T>&), and f(const T*).


    Basically, the name of a called function is dependent
	if it is obviously dependent by looking at its
	arguments or at its formal parameters.
*/

template<typename T>
T f(T a)
{
	return g(a); // Ok: a is a dependent name
	 // and therefore is g;
}

class Quad { /* ..*/  };

void g(Quad);
int z = f(Quad{2}); // f's g is bound to g(Quad)

/*
	By default, a dependent name is assumed
	to name something that is not a type.

	So, to use a dependent name as a type
	, you have to say so, using the keyword typename.
*/

template<typename Container>
void fct(Container& c)
{
	typename Container::value_type v2 = c[9]; // value_type is assumed to
		// name a type
	Container::value_type v1 = c[7];// syntax error
	auto v3 = c[11]; // 
}

/*
	We can avoid such awkward use
	of typename by introducing type alias
*/

template<typename T>
using Value_type<T> = 
	typename T::value_type;

template<typename Container>
void fct2(Container& c)
{
	Value_type<Container> v1 = c[9];
}


/*
	Point-of-Definition Binding
	-------------------------------------------

	When a compiler sees a template definition,
	it determines which names are dependent.

	If a name is dependent, looking for its 
	declaration is postponed until instantiation time.

	Names that do not depend on the template argument
	are treated like names that are not in templates;
	but they must be in scope at the point of definition.

*/

int x;

template<typename T>
T f(T a)
{
	++x; // Is in scope
	++y; // error not in scope
	return a; // Ok: a is dependent
}

int y;

int z = f(2);

/*
	Point-of-Instantiation Binding
	-------------------------------------
	
	The context used to determine the meaning
	of a dependent name is determined by the
	use of a template with a given set of 
	arguments.

	This is called point of instantiation
	for that specialization.
	
	Each use of a template for a given
	set of template arguments defines a point
	of instantiation.

	For a function template that point is 
	the nearest global or namespace scope
	enclosing its use, just after the declaration
	that contains that use.

*/
void g(int);

template<typename T>
T f(T a)
{
	g(a); // g is bound at point of instantiation
}

void h(int i)
{
	extern void g(double);
	f(i);
}
// point of declaration for f<int>
/*
	The point of instantiation for  f<int>
	is outside h().

	This is essential that the g() called
	in f() ist the global g(int) rather than
	the local g(double).

	An unqualified name used in a template
	definition can never be bound to a
	local name.
*/

/*
	To enable recursive calls, the point
	of declaration for a function template
	is after the declaration tha instatiates it.

*/
void g(int);

template<typename T>
T f(T a)
{
	g(a); // bound at point of instantiation
	if (i) h(a - 1); // h is bound at point of instantiation
}



void h(int i)
{
	extern void g(double);
	f(i);
}
// declaration for f<int>

/* 
	For a template class or class 
	member, the point of instatiation is
	just before the declaration containing
	its use.
*/

template<typename T>
class Container {
	vector<T> v; // elements
	//..
public:
	void sort(); // sort elements
	// ..
};

// point of instantiation of Container<int>
void f()
{
	Container<int> c; //point of use;
	c.sort();
}
/* 
	Multiple Instantiation Points
	-----------------------------------------

    Names from Base Classes
	-----------------------------------------
	Whan a class template has a base class,
	it can access names from that base.
	As for other names, there are two
	distinct possibilities:

	1. The base class depends on a template
	   argument.
	2. The base class does not depend on
	   a template argument.
    


	
	










*/















































